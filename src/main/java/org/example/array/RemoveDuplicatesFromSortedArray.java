package org.example.array;

/*
Дан целочисленный массив nums, отсортированный в порядке неубывания.
Удалите дубликаты на месте так, чтобы каждый уникальный элемент встречался только один раз.
Относительный порядок элементов должен остаться прежним.
Затем верните количество уникальных элементов в nums.

Чтобы количество уникальных элементов nums стало k, вам нужно сделать следующее:

Измените массив nums таким образом, чтобы первые k элементов nums содержали уникальные элементы
 в том порядке, в котором они присутствовали в nums изначально. Остальные элементы nums не важны,
  как и размер nums.
Возврат.
Судья по Обычаю:

Судья протестирует ваше решение с помощью следующего кода:

int[] nums = [...]; // Входной массив
int[] expectedNums = [...]; // Ожидаемый ответ правильной длины

int k = removeDuplicates(nums); // Вызывает вашу реализацию

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
Если все утверждения пройдут, то ваше решение будет принято.



Пример 1:

Входные данные: nums = [1,1,2]
Выходные данные: 2, nums = [1,2,_]
Пояснение: Ваша функция должна возвращать k = 2, при этом первые два элемента массива nums
должны быть равны 1 и 2 соответственно.
Не имеет значения, что вы оставляете после возвращаемого k (поэтому это подчёркивания).
 */

public class RemoveDuplicatesFromSortedArray {

    public static void main(String[] args) {

        int[] nums = {1,1,2,3,4,4,5,6,6};

        System.out.println(removeDuplicates(nums));
    }

    public static int removeDuplicates(int[] nums) {
        if (nums.length == 0) {
            return 0;
        } else {
            int result = 0;
            for (int i = 0; i < nums.length; i++) {
                if (nums[result] != nums[i]) {
                    nums[++result] = nums[i];
                }
            }
            return result + 1;
        }
    }
}
